# 分布式一致性协议

##Paxos

##raft

### 具体过程

1. 动画展示

   http://thesecretlivesofdata.com/raft/

2. 过程
   1. 每个节点可以有三种状态
      * Follower
      * Candidate
      * Leader
3. leader election
   1. 在系统刚开始的时候，所有的节点都是Follower的状态
   2. 如果follower在一段时间内听不到leader的心跳，则它们自己就会变成Candidate
      1. 每个节点的这个时间是随机的，从150ms到300ms, **election timeout**
   3. 一个节点的超时时间一旦到达，它就把自己变成Candidate，并向其他节点发送vote，vote自己为leader
   4. 如果一个candidate获取了半数的vote，那么它就是新的leader了
4. Log Replication
   1. 后面所有的修改都是通过leader的
   2. 每个修改都被append到节点的log中，但是log并没有commit，所以节点的值还不会被更新
   3. leader会把这次修改发送到它的follower节点中
   4. 当有超过半数的节点回复的时候，leader节点就会把这次的修改commit
   5. 之后，leader再想follower发送一个心跳包(发送间隔为 **heartbeat timeout**)，告知commit这个log
5. 在四个节点的集群中，如果有两个节点同时成为了candidate，并且也恰好另外两个节点各成为其中一个节点的follower，形成一个2v2的局面，那么这个时候是选不出leader，需要再重新等待一个election timeout重新选举
6. 在一个5个节点的集群中，如果出现了脑裂，比如说一个两个节点，一个三节点，原来的主在二节点的网络分区中，那么经过一次选举，三个节点的分区中，会重新选出主来，那么原来5个节点的集群，就有两个master节点了。但是集群的配置还是5，这个时候，只有想那个只有三个节点的分区写入才能写入成功，只有两个节点的那个分区写入永远都不能成功，这是因为，只有两个节点，不能达到集群规模的半数以上，达不成一致。
   1. 当网络恢复后，2节点网络分区，会收到比自己大的election term， 所以要把之前接受到的一些更新回退

### 应用

1. redis的sentinel